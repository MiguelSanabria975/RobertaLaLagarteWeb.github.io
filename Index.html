<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"
    />
    <title>WebAR – ROBERTA LA LAGARTA</title>

    <!-- Librerías -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.1.4/dist/mindar-image-three.prod.js"></script>

    <link rel="preload" href="Img/IconSound.png" as="image" />

    <style>
      :root {
        --vh: 1vh;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        -webkit-user-select: none;
        user-select: none;
      }

      #ar-container {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100dvh;
        height: calc(var(--vh) * 100);
      }
      #fps {
        position: fixed;
        right: 0.5rem;
        bottom: 0.5rem;
        color: #9ad;
        font: 12px/1 system-ui;
        opacity: 0.85;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.35);
        z-index: 5;
      }

      /* Splash minimal sólo con icono */
      #splash {
        position: fixed;
        inset: 0;
        z-index: 20;
        display: grid;
        place-items: center;
        background: transparent; /* ← comenta esta línea si quieres el oscurecido original */
        opacity: 0;
        pointer-events: auto;
        transition: opacity 220ms ease;
        -webkit-tap-highlight-color: transparent;
      }
      #splash.show {
        opacity: 1;
      }

      #touch-hint {
        width: clamp(72px, 22vw, 140px);
        max-width: 45dvw;
        image-rendering: -webkit-optimize-contrast;
        -webkit-user-drag: none;
        user-select: none;
        filter: drop-shadow(0 6px 20px rgba(0, 0, 0, 0.35));
        animation: popfade 1.6s ease both; /* dura ~1.6s visible */
      }

      @keyframes popfade {
        0% {
          opacity: 0;
          transform: scale(0.92);
        }
        12% {
          opacity: 1;
          transform: scale(1);
        }
        80% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }

      /* Spinner ultraligero (solo si el reveal tarda) */
      #spinner {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        z-index: 30;
        pointer-events: none; /* no bloquea toques */
      }
      #spinner[hidden] {
        display: none;
      }
      #spinner .ring {
        width: 32px;
        height: 32px;
        border: 2.5px solid rgba(230, 239, 255, 0.25);
        border-top-color: #4da3ff;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        box-shadow: 0 0 0 1px transparent;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div id="ar-container"></div>
    <div id="fps" aria-hidden="true"></div>

    <!-- Splash informativo: icono que se auto-oculta; cualquier toque desbloquea audio -->
    <div id="splash" aria-hidden="false">
      <img
        id="touch-hint"
        src="Img/IconSound.png"
        alt="Toca para activar audio"
      />
    </div>

    <!-- Spinner ultraligero (se muestra sólo si el reveal tarda) -->
    <div id="spinner" hidden aria-hidden="true">
      <div class="ring" role="status" aria-label="Cargando"></div>
    </div>

    <script type="module">
      /* ================= CONFIG ================= */
      const SPLASH_AUTOHIDE_MS = 100000; // el splash desaparece solo
      const SPINNER_DELAY_MS = 800; // muestra spinner si el reveal tarda más que esto
      const VOLUMES_BY_AUDIOBASE = {
        "Audio/PajarosSingle": 1.0,
        "Audio/SoundVideo01": 1.0,
        "Audio/Sonido_Video02": 1.0,
      };

      /* ====== FIX 100vh iOS ====== */
      const fixVH = () => {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty("--vh", `${vh}px`);
      };
      fixVH();
      addEventListener("resize", fixVH);
      addEventListener("orientationchange", fixVH);

      /* ====== Calidad: baseline iOS + adaptativo por FPS ====== */
      // Detección robusta de iOS/iPadOS (incluye iPadOS como "Mac" con touch)
      const isIOS = (() => {
        const p = navigator.platform || "";
        const ua = navigator.userAgent || "";
        const touchMac = /Mac/.test(p) && navigator.maxTouchPoints > 1;
        return (
          /iPhone|iPad|iPod/.test(p) || touchMac || /iPhone|iPad|iPod/.test(ua)
        );
      })();

      // Bootstrap prudente (en iOS no confíes en deviceMemory/hardwareConcurrency)
      let calidad = bootstrapQuality();
      function bootstrapQuality() {
        if (isIOS) return "mid";
        const mem =
          typeof navigator.deviceMemory === "number"
            ? navigator.deviceMemory
            : 4;
        const cpu =
          typeof navigator.hardwareConcurrency === "number"
            ? navigator.hardwareConcurrency
            : 6;
        if (mem >= 8 && cpu >= 8) return "hd";
        if (mem >= 4 && cpu >= 4) return "mid";
        return "low";
      }

      // Escalado por calidad para conteos (se recalcula con 'calidad' actual)
      const scaleByQuality = (n) =>
        calidad === "low" ? 0 : calidad === "mid" ? Math.round(n * 0.6) : n;
      const particlesEnabled = () => calidad !== "low";

      /* ====== Partículas ====== */
      const createPoints = (positions, size, color) => {
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        const material = new THREE.PointsMaterial({
          size,
          color,
          transparent: true,
          opacity: 0.9,
          depthWrite: false,
        });
        return new THREE.Points(geometry, material);
      };
      const Particles = {
        rain: ({
          count = 50,
          areaY = 0.5,
          speed = 0.01,
          color = 0xffffff,
          depthX = 0.1,
          depthZ = 0.2,
          size = 10,
          position = { x: 0, y: 0, z: 0 },
        }) => {
          count = scaleByQuality(count);
          if (!count) return null;
          const positions = new Float32Array(count * 3);
          for (let i = 0; i < count; i++) {
            positions[i * 3] = (Math.random() - 0.5) * depthX;
            positions[i * 3 + 1] = Math.random() * areaY;
            positions[i * 3 + 2] = (Math.random() - 0.5) * depthZ;
          }
          const p = createPoints(positions, size, color);
          p.position.set(position.x || 0, position.y || 0, position.z || 0);
          p.userData = { type: "rain", speed, areaY };
          return p;
        },
        foam: ({
          count = 50,
          areaY = 0.3,
          areaX = 1,
          speed = 0.002,
          color = 0x33cfff,
          depthX = 0.8,
          depthZ = 0.02,
          size = 10,
          position = { x: 0, y: 0, z: 0 },
        }) => {
          count = scaleByQuality(count);
          if (!count) return null;
          const positions = new Float32Array(count * 3);
          for (let i = 0; i < count; i++) {
            positions[i * 3] = (Math.random() - 0.5) * depthX;
            positions[i * 3 + 1] = (Math.random() - 0.5) * areaY;
            positions[i * 3 + 2] = (Math.random() - 0.5) * depthZ;
          }
          const p = createPoints(positions, size, color);
          p.position.set(position.x || 0, position.y || 0, position.z || 0);
          p.userData = { type: "foam", speed, areaY };
          return p;
        },
        dragonfly: ({
          count = 10,
          color = 0xffcc00,
          areaY = 0.3,
          areaX = 1,
          speed = 0.002,
          depthZ = 0.02,
          size = 10,
          position = { x: 0, y: 0, z: 0 },
        }) => {
          count = scaleByQuality(count);
          if (!count) return null;
          const positions = new Float32Array(count * 3);
          for (let i = 0; i < count; i++) {
            positions[i * 3] = (Math.random() - 0.5) * areaX;
            positions[i * 3 + 1] = (Math.random() - 0.5) * areaY;
            positions[i * 3 + 2] = (Math.random() - 0.5) * depthZ;
          }
          const p = createPoints(positions, size, color);
          p.position.set(position.x || 0, position.y || 0, position.z || 0);
          p.userData = { type: "dragonfly", areaX, areaY, speed };
          return p;
        },
        fire: ({
          count = 30,
          areaX = 0.25,
          areaY = 0.25,
          speed = 0.002,
          color = 0xff3300,
          size = 10,
          position = { x: 0, y: 0, z: 0 },
        }) => {
          count = scaleByQuality(count);
          if (!count) return null;
          const positions = new Float32Array(count * 3);
          for (let i = 0; i < count; i++) {
            positions[i * 3] = (Math.random() - 0.5) * areaX;
            positions[i * 3 + 1] = Math.random() * areaY;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
          }
          const p = createPoints(positions, size, color);
          p.position.set(position.x || 0, position.y || 0, position.z || 0);
          p.userData = { type: "fire", speed, areaY };
          return p;
        },
      };

      /* ====== Shader de croma (precision Android) ====== */
      const makeChromaMaterial = (texture, key = 0x0f00da) => {
        const col = new THREE.Color(key);
        return new THREE.ShaderMaterial({
          uniforms: {
            map: { value: texture },
            keyColor: { value: col },
            similarity: { value: 0.15 },
            smoothness: { value: 0.6 },
          },
          transparent: true,
          vertexShader: `
            precision mediump float;
            varying vec2 vUv;
            void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }
          `,
          fragmentShader: `
            precision mediump float;
            uniform sampler2D map; uniform vec3 keyColor;
            uniform float similarity; uniform float smoothness;
            varying vec2 vUv;
            void main(){
              vec4 tex = texture2D(map, vUv);
              float Y = dot(tex.rgb, vec3(0.2989,0.5866,0.1145));
              float Cr = tex.r - Y; float Cb = tex.b - Y;
              float Yk = dot(keyColor.rgb, vec3(0.2989,0.5866,0.1145));
              float Crk = keyColor.r - Yk; float Cbk = keyColor.b - Yk;
              float diff = distance(vec2(Cr,Cb), vec2(Crk,Cbk));
              float alpha = smoothstep(similarity, similarity+smoothness, diff);
              gl_FragColor = vec4(tex.rgb, alpha);
            }
          `,
        });
      };

      /* ====== MindAR ====== */
      const mindarThree = new window.MINDAR.IMAGE.MindARThree({
        container: document.querySelector("#ar-container"),
        imageTargetSrc: "TargetsMind/MultiTarget.mind",
        filterMinCF: 0.05,
        filterBeta: 0.01,
      });
      const { renderer, scene, camera } = mindarThree;

      if (renderer.outputEncoding !== undefined)
        renderer.outputEncoding = THREE.sRGBEncoding;
      try {
        renderer.getContext().getContextAttributes().powerPreference =
          "low-power";
      } catch {}

      // Setter central de calidad (reaplica DPR y oculta partículas si baja a "low")
      function setQuality(next) {
        const prev = calidad;
        const changed = prev !== next;
        calidad = next;

        const pxr = calidad === "low" ? 0.75 : calidad === "mid" ? 1.0 : 1.25; // cap amigable
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, pxr));

        if (
          changed &&
          typeof targets !== "undefined" &&
          prev !== "low" &&
          calidad === "low"
        ) {
          // Si había partículas visibles, escóndelas al bajar a low
          targets.forEach((t) => {
            if (t.particles) t.particles.visible = false;
          });
        }
      }
      // Aplica el baseline inicial
      setQuality(calidad);

      /* ====== Solo AAC (.m4a) ====== */
      const sharedPlane = new THREE.PlaneGeometry(0.9, 0.8);
      const pickAAC = (basePath) => `${basePath}.m4a`;

      /* ====== Audio Manager con Crossfade Maestro ====== */
      class WebAudioManager {
        constructor() {
          const Ctx = window.AudioContext || window.webkitAudioContext;
          this.ctx = new Ctx();
          this.buffers = new Map(); // key -> AudioBuffer
          this.playing = new Map(); // key -> { src, gain, baseVol, stopTimer? }
          this.master = this.ctx.createGain();
          this.master.gain.value = 1;
          this.master.connect(this.ctx.destination);
          this.unlocked = this.ctx.state === "running";

          this.cross = { enabled: true, backgroundLevel: 0.18, fadeMs: 700 };
          this.focusKey = null;
        }
        async resume() {
          if (this.ctx.state !== "running") await this.ctx.resume();
          this.unlocked = true;
        }

        async load(basePath) {
          if (this.buffers.has(basePath)) return this.buffers.get(basePath);
          const urls = [`${basePath}.m4a`, `${basePath}.mp3`];
          let lastErr;
          for (const url of urls) {
            try {
              const res = await fetch(url);
              if (!res.ok)
                throw new Error(`Audio no encontrado: ${url} (${res.status})`);
              const arr = await res.arrayBuffer();
              const buf = await this.ctx.decodeAudioData(arr);
              this.buffers.set(basePath, buf);
              return buf;
            } catch (e) {
              lastErr = e;
            }
          }
          throw lastErr;
        }
        _rampTo(g, target, ms = this.cross.fadeMs) {
          const now = this.ctx.currentTime;
          g.gain.setValueAtTime(g.gain.value, now);
          g.gain.linearRampToValueAtTime(target, now + ms / 1000);
        }
        async playLoop(basePath, volume = 1.0, fadeMs = this.cross.fadeMs) {
          const buf = await this.load(basePath);
          if (this.playing.has(basePath)) {
            const h = this.playing.get(basePath);
            h.baseVol = volume;
            this._rampTo(h.gain, volume, fadeMs);
            return h;
          }
          const src = this.ctx.createBufferSource();
          src.buffer = buf;
          src.loop = true;
          const gain = this.ctx.createGain();
          gain.gain.value = 0;
          src.connect(gain).connect(this.master);
          src.start(0);
          const handle = { src, gain, baseVol: volume, stopTimer: null };
          this.playing.set(basePath, handle);
          this._rampTo(gain, volume, fadeMs);
          return handle;
        }
        stopWithFade(basePath, fadeMs = this.cross.fadeMs) {
          const h = this.playing.get(basePath);
          if (!h) return;
          if (h.stopTimer) {
            clearTimeout(h.stopTimer);
            h.stopTimer = null;
          }
          this._rampTo(h.gain, 0, fadeMs);
          h.stopTimer = setTimeout(() => {
            try {
              h.src.stop(0);
            } catch {}
            try {
              h.src.disconnect();
              h.gain.disconnect();
            } catch {}
            this.playing.delete(basePath);
            if (this.focusKey === basePath) this.focusKey = null;
          }, fadeMs + 30);
        }
        stop(basePath) {
          const h = this.playing.get(basePath);
          if (!h) return;
          try {
            h.src.stop(0);
          } catch {}
          try {
            h.src.disconnect();
            h.gain.disconnect();
          } catch {}
          if (h.stopTimer) clearTimeout(h.stopTimer);
          this.playing.delete(basePath);
          if (this.focusKey === basePath) this.focusKey = null;
        }
        stopAllWithFade(ms = 250) {
          for (const k of Array.from(this.playing.keys()))
            this.stopWithFade(k, ms);
        }
        stopAll() {
          for (const k of Array.from(this.playing.keys())) this.stop(k);
        }
        masterCrossfadeTo(basePath, fadeMs = this.cross.fadeMs) {
          if (!this.cross.enabled) return;
          this.focusKey = basePath;
          for (const [k, h] of this.playing.entries()) {
            const targetVol =
              k === basePath
                ? h.baseVol
                : h.baseVol * this.cross.backgroundLevel;
            this._rampTo(h.gain, targetVol, fadeMs);
          }
        }
        setCrossfadeConfig({ backgroundLevel, fadeMs }) {
          if (typeof backgroundLevel === "number")
            this.cross.backgroundLevel = backgroundLevel;
          if (typeof fadeMs === "number") this.cross.fadeMs = fadeMs;
        }
      }
      const AudioMgr = new WebAudioManager();
      let audioUnlocked = AudioMgr.unlocked;

      /* ====== Definición de targets ====== */
      const targets = [
        {
          index: 0,
          audioBase: "Audio/PajarosSingle",
          audioBase: "VozOff/RobertaLaLagarta",
          layers: [
            {
              src: "Animations/Video00_ConFondo.mp4",
              x: 0.03,
              scale: 0.92,
              chroma: "0xDCCD00",
            },
            {
              src: "Animations/Video00_Titulo.mp4",
              z: 0.1,
              y: 0.1,
              x: -0.01,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 1,
          audioBase: "Audio/SoundVideo01",
          layers: [
            {
              src: "Animations/Video01_FondoConFondo.mp4",
              z: -0.02,
              x: -0.08,
              y: 0.02,
              scale: 0.9,
              chroma: "0x0f00da",
            },
            { src: "Animations/Video01_Mitad.mp4", z: 0.1, chroma: "0x0f00da" },
          ],
        },
        {
          index: 2,
          audioBase: "Audio/Sonido_Video02",
          layers: [
            {
              src: "Animations/Video02.mp4",
              z: 0.1,
              x: -0.05,
              scale: 1.2,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 3,
          audioBase: "Audio/Sonido_Video03",
          layers: [
            { src: "Animations/Video03_Mitad.mp4", z: 0, chroma: "0x0f00da" },
            {
              src: "Animations/Video03_Frente.mp4",
              z: 0.1,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 4,
          audioBase: "Audio/Sonido_Video04",
          layers: [
            {
              src: "Animations/Video04.mp4",
              z: 0.1,
              scale: 1.2,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 5,
          audioBase: "Audio/Sonido_Video05",
          layers: [
            {
              src: "Animations/Video05_ConFondo.mp4",
              z: 0,
              scale: 1.1,
              x: 0.08,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 6,
          audioBase: "Audio/Sonido_Video06",
          layers: [
            {
              src: "Animations/Video06_Fondo.mp4",
              z: 0.02,
              x: -0.08,
              scale: 1.2,
              chroma: "0x0f00da",
            },
            {
              src: "Animations/Video06_Frente.mp4",
              z: 0.05,
              x: -0.08,
              scale: 1.2,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 7,
          audioBase: "Audio/Sonido_Video07",
          layers: [
            { src: "Animations/Video07.mp4", z: 0.2, chroma: "0x0f00da" },
          ],
        },
        {
          index: 8,
          audioBase: "Audio/Sonido_Video07",
          layers: [
            {
              src: "Animations/Video08.mp4",
              z: 0,
              scale: 1.2,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 9,
          audioBase: "Audio/Sonido_Video07",
          layers: [
            {
              src: "Animations/Video09.mp4",
              z: 0,
              y: -0.1,
              scale: 1.0,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 10,
          audioBase: "Audio/Sonido_Video10",
          layers: [
            {
              src: "Animations/Video10.mp4",
              z: 0.02,
              y: 0.1,
              x: 0.1,
              scale: 1.5,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 11,
          audioBase: "Audio/Sonido_Video11",
          layers: [
            {
              src: "Animations/Video11.mp4",
              z: 0.1,
              scale: 1.1,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 12,
          audioBase: "Audio/Sonido_Video12",
          layers: [
            { src: "Animations/Video12.mp4", z: 0.1, chroma: "0x0f00da" },
          ],
        },
        {
          index: 13,
          audioBase: "Audio/Sonido_Video13",
          layers: [
            { src: "Animations/Video13.mp4", z: 0.1, chroma: "0x0f00da" },
          ],
        },
        {
          index: 14,
          audioBase: "Audio/Sonido_Video13",
          layers: [
            {
              src: "Animations/Video14.mp4",
              z: 0,
              y: 0.1,
              scale: 1.3,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 15,
          audioBase: "Audio/Sonido_Video15",
          layers: [
            {
              src: "Animations/Video15.mp4",
              z: 0,
              x: -0.1,
              y: 0.1,
              scale: 1.2,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 16,
          audioBase: "Audio/Sonido_Video16",
          layers: [
            {
              src: "Animations/Video16.mp4",
              z: 0,
              scale: 1.2,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 17,
          audioBase: "Audio/Sonido_Video13",
          layers: [
            {
              src: "Animations/Video17.mp4",
              z: 0,
              scale: 1.2,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 18,
          audioBase: "Audio/Sonido_Video18",
          layers: [
            {
              src: "Animations/Video18.mp4",
              scale: 1.2,
              y: 0.08,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 19,
          audioBase: "Audio/Sonido_Video19",
          layers: [
            { src: "Animations/Video19.mp4", y: -0.08, chroma: "0x0f00da" },
          ],
        },
        {
          index: 20,
          audioBase: "Audio/Sonido_Video20",
          layers: [
            {
              src: "Animations/Video20Fondo.mp4",
              z: 0,
              y: 0.05,
              x: 0.05,
              scale: 1.2,
              chroma: "0x0f00da",
            },
            {
              src: "Animations/Video20Frente.mp4",
              z: 0.2,
              scale: 1.2,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 21,
          audioBase: "Audio/Sonido_Video04",
          layers: [{ src: "Animations/Video21.mp4", z: 0, chroma: "0x0f00da" }],
        },
        {
          index: 22,
          audioBase: "Audio/Sonido_Video22",
          layers: [
            {
              src: "Animations/Video22.mp4",
              z: 0,
              y: 0.15,
              scale: 1.05,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 23,
          audioBase: "Audio/PajarosSingle",
          layers: [
            {
              src: "Animations/Video23.mp4",
              scale: 1.1,
              y: 0.02,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 24,
          audioBase: "Audio/Sonido_Video10",
          layers: [
            {
              src: "Animations/Video24.mp4",
              scale: 1.15,
              x: 0.02,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 25,
          audioBase: "Audio/Sonido_Video25",
          layers: [
            {
              src: "Animations/Video25.mp4",
              z: 0,
              scale: 1.5,
              y: -0.1,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 26,
          audioBase: "Audio/Sonido_Video22",
          layers: [
            {
              src: "Animations/Video26.mp4",
              scale: 0.8,
              y: -0.05,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 27,
          audioBase: "Audio/Sonido_Video27",
          layers: [
            {
              src: "Animations/Video27.mp4",
              z: 0,
              scale: 1.5,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 28,
          audioBase: "Audio/Sonido_Video28",
          layers: [
            {
              src: "Animations/Video28.mp4",
              z: 0,
              scale: 1.2,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 29,
          audioBase: "Audio/Sonido_Video29",
          layers: [
            {
              src: "Animations/Video29.mp4",
              z: 0,
              scale: 1.2,
              y: 0.1,
              x: -0.1,
              chroma: "0x0f00da",
            },
          ],
        },
        {
          index: 30,
          audioBase: "Audio/PajarosSingle",
          layers: [
            {
              src: "Animations/Video30.mp4",
              z: 0.1,
              x: 0.04,
              y: 0,
              scale: 1.1,
              chroma: "0x0f00da",
            },
          ],
        },
      ];

      // Partículas por target
      const particleMap = {
        0: {
          type: "foam",
          params: {
            count: 300,
            areaY: 0.2,
            areaX: 5,
            speed: 0.0002,
            size: 15,
            color: 0xffff,
            position: { x: 0, y: -0.25, z: 0.1 },
          },
        },
        1: {
          type: "rain",
          params: {
            count: 300,
            areaY: 0.7,
            depthX: 1,
            speed: 0.005,
            size: 7,
            color: 0x3642fa,
          },
        },
        2: {
          type: "dragonfly",
          params: {
            count: 100,
            size: 12,
            color: 0xc020fa,
            speed: 3,
            areaX: 0.7,
            areaY: 0.7,
          },
        },
        3: {
          type: "rain",
          params: {
            count: 300,
            areaY: 0.7,
            depthX: 0.8,
            speed: 0.005,
            size: 10,
            color: 0x3642fa,
          },
        },
        5: {
          type: "foam",
          params: {
            count: 300,
            areaY: 0.6,
            areaX: 6,
            speed: 0.008,
            size: 10,
            color: 0xffff,
            position: { x: 0, y: 0, z: -0.1 },
          },
        },
        11: {
          type: "foam",
          params: {
            count: 200,
            areaY: 0.5,
            areaX: 5,
            speed: 0.0008,
            size: 10,
            color: 0xf00111,
            position: { x: 0, y: 0, z: -0.1 },
          },
        },
        12: {
          type: "foam",
          params: {
            count: 300,
            areaY: 0.7,
            areaX: 5,
            depthZ: -0.5,
            speed: 0.0008,
            size: 10,
            color: 0xf00111,
            position: { x: 0, y: 0.1, z: 0.2 },
          },
        },
        13: {
          type: "fire",
          params: {
            count: 50,
            areaY: 0.3,
            speed: 0.0008,
            size: 0.001,
            color: 0xff3300,
            position: { x: 0.18, y: -0.14, z: 0.2 },
          },
        },
        14: {
          type: "fire",
          params: {
            count: 100,
            areaY: 0.3,
            areaX: 0.5,
            size: 18,
            color: 0xff3300,
            position: { x: 0.1, y: 0, z: -0.1 },
          },
        },
        15: {
          type: "foam",
          params: {
            count: 300,
            areaY: 0.7,
            areaX: 6,
            speed: 0.0008,
            size: 10,
            color: 0xff3300,
            position: { x: 0, y: 0.1, z: -0.1 },
          },
        },
        16: {
          type: "fire",
          params: {
            count: 300,
            areaY: 0.7,
            areaX: 0.7,
            speed: 0.0008,
            size: 10,
            color: 0xff3300,
            position: { x: 0, y: -0.3, z: -0.1 },
          },
        },
        17: {
          type: "foam",
          params: {
            count: 100,
            areaY: 0.9,
            areaX: 0.9,
            speed: 0.0008,
            size: 10,
            color: 0xff3300,
            position: { x: -0.1, y: -0.06, z: -0.1 },
          },
        },
        19: {
          type: "fire",
          params: {
            count: 50,
            areaY: 0.1,
            size: 0.01,
            color: 0xff3300,
            position: { x: -0.08, y: -0.05, z: 0.2 },
          },
        },
        20: {
          type: "rain",
          params: {
            count: 300,
            areaY: 0.7,
            depthX: 1,
            speed: 0.005,
            size: 0.01,
            color: 0x3642fa,
            position: { x: 0, y: 0, z: 0.3 },
          },
        },
        24: {
          type: "fire",
          params: {
            count: 300,
            areaY: 0.7,
            areaX: 0.5,
            speed: 0.0008,
            size: 10,
            color: 0xce88d8,
            position: { x: -0.1, y: -0.3, z: -0.1 },
          },
        },
        25: {
          type: "foam",
          params: {
            count: 300,
            areaY: 0.3,
            areaX: 10,
            speed: 0.0008,
            size: 10,
            color: 0xffff,
            position: { x: 0, y: -0.2, z: 0.2 },
          },
        },
        28: {
          type: "rain",
          params: {
            count: 300,
            areaY: 0.7,
            depthX: 1,
            speed: 0.0005,
            size: 25,
            color: 0x9b3496,
            position: { x: 0, y: -0.2, z: -0.1 },
          },
        },
        29: {
          type: "foam",
          params: {
            count: 300,
            areaY: 0.8,
            areaX: 10,
            speed: 0.0008,
            size: 10,
            color: 0xffff,
            position: { x: 0, y: 0, z: -0.1 },
          },
        },
        30: {
          type: "foam",
          params: {
            count: 100,
            areaY: 0.8,
            areaX: 10,
            speed: 0.0008,
            size: 10,
            color: 0xfce733,
            position: { x: 0, y: 0, z: -0.1 },
          },
        },
      };

      // Estado
      const activeTargets = new Set();

      /* ====== Spinner helpers ====== */
      let spinnerTimer = null;
      const spinnerEl = document.getElementById("spinner");
      const showSpinner = () => {
        spinnerEl?.removeAttribute("hidden");
      };
      const hideSpinner = () => {
        if (spinnerTimer) {
          clearTimeout(spinnerTimer);
          spinnerTimer = null;
        }
        spinnerEl?.setAttribute("hidden", "");
      };

      /* ====== Helpers video/sincronía ====== */
      const waitVideoFirstFrame = (video, maxWaitMs = 2500) =>
        new Promise((resolve) => {
          let done = false;
          const finish = () => {
            if (!done) {
              done = true;
              cleanup();
              resolve();
            }
          };
          const cleanup = () => {
            video.removeEventListener("playing", finish);
            video.removeEventListener("loadeddata", finish);
            video.removeEventListener("seeked", finish);
          };
          if (typeof video.requestVideoFrameCallback === "function") {
            const cb = () => finish();
            video.requestVideoFrameCallback(cb);
          } else {
            video.addEventListener("playing", finish, { once: true });
            video.addEventListener("loadeddata", finish, { once: true });
            video.addEventListener("seeked", finish, { once: true });
          }
          setTimeout(finish, maxWaitMs);
        });

      const prepareVideo = async (video) => {
        try {
          video.muted = true;
          video.loop = true;
          video.preload = "auto";
        } catch {}
        try {
          await video.play();
        } catch {}
        try {
          video.pause();
        } catch {}
        try {
          video.currentTime = 0.03;
        } catch {}
        await waitVideoFirstFrame(video);
      };

      const prewarmMaterials = () =>
        new Promise((res) => {
          requestAnimationFrame(() => res());
        });

      async function revealInSync(target) {
        target._gen = (target._gen || 0) + 1;
        const myGen = target._gen;

        if (spinnerTimer) {
          clearTimeout(spinnerTimer);
        }
        spinnerTimer = setTimeout(() => showSpinner(), SPINNER_DELAY_MS);

        target.layerObjs.forEach(({ mesh }) => (mesh.visible = false));
        if (target.particles) target.particles.visible = false;

        const videos = target.layerObjs.map((o) => o.video);
        await Promise.all(videos.map((v) => prepareVideo(v)));

        await prewarmMaterials();

        if (target._gen !== myGen) {
          hideSpinner();
          return;
        }

        videos.forEach((v) => {
          try {
            v.currentTime = 0;
          } catch {}
        });
        await new Promise((r) => requestAnimationFrame(r));
        target.layerObjs.forEach(({ mesh }) => (mesh.visible = true));
        videos.forEach((v) => v.play().catch(() => {}));
        if (target.particles) target.particles.visible = true;

        hideSpinner();
      }

      /* ====== Crear capa de video ====== */
      const createVideoLayer = (layerCfg) => {
        const { src, z = 0, x = 0, y = 0, scale = 1, chroma } = layerCfg;
        const video = document.createElement("video");
        video.crossOrigin = "anonymous";
        video.loop = true;
        video.muted = true;
        video.playsInline = true;
        video.autoplay = false;
        video.preload = "auto";
        video.setAttribute("playsinline", "");
        video.setAttribute("webkit-playsinline", "true");
        video.disablePictureInPicture = true;
        video.src = src;

        const texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        if ("colorSpace" in texture) texture.colorSpace = THREE.SRGBColorSpace;
        video.addEventListener("loadeddata", () => {
          texture.needsUpdate = true;
        });

        const geom = sharedPlane.clone();
        const uv = geom.attributes.uv.array; // leve recorte de bordes
        uv[0] = 0.01;
        uv[2] = 0.99;
        uv[4] = 0.01;
        uv[6] = 0.99;
        geom.attributes.uv.needsUpdate = true;

        const material =
          typeof chroma === "string" && chroma
            ? makeChromaMaterial(texture, Number(chroma.replace("#", "0x")))
            : new THREE.MeshBasicMaterial({ map: texture, transparent: false });

        const mesh = new THREE.Mesh(geom, material);
        mesh.position.set(x, y, z);
        mesh.scale.set(scale, scale, 1);
        mesh.visible = false; // el reveal es orquestado en bloque
        return { video, texture, mesh };
      };

      const disposeLayer = (layer) => {
        if (!layer) return;
        try {
          layer.video.pause();
        } catch {}
        if (layer.texture) {
          layer.texture.dispose();
        }
        if (layer.mesh) {
          if (layer.mesh.material?.map?.dispose)
            layer.mesh.material.map.dispose();
          if (layer.mesh.material?.dispose) layer.mesh.material.dispose();
          if (layer.mesh.geometry?.dispose) layer.mesh.geometry.dispose();
        }
      };

      // ====== Anchors y lógica por target ======
      targets.forEach((t) => {
        const anchor = mindarThree.addAnchor(t.index);
        t.anchor = anchor;
        t.layersCreated = false;
        t.layerObjs = [];
        t.cleanupTimeout = null;
        t.particles = null;

        const ensureLayers = async () => {
          if (t.layersCreated) return;
          for (const layerCfg of t.layers) {
            const obj = createVideoLayer(layerCfg);
            t.layerObjs.push(obj);
            anchor.group.add(obj.mesh);
          }
          t.layersCreated = true;
        };
        const ensureParticles = () => {
          if (!particlesEnabled()) return;
          if (t.particles) return;
          const pcfg = particleMap[t.index];
          if (!pcfg) return;
          const p = Particles[pcfg.type](pcfg.params);
          if (!p) return;
          t.particles = p;
          t.particles.visible = false;
          anchor.group.add(p);
        };
        const volumeFor = (audioBase) => VOLUMES_BY_AUDIOBASE[audioBase] ?? 1.0;

        anchor.onTargetFound = async () => {
          activeTargets.add(t.index);
          if (t.cleanupTimeout) {
            clearTimeout(t.cleanupTimeout);
            t.cleanupTimeout = null;
          }

          AudioMgr.load(t.audioBase).catch(() => {});

          await ensureLayers();
          ensureParticles();

          await revealInSync(t);

          if (audioUnlocked) {
            const vol = volumeFor(t.audioBase);
            AudioMgr.playLoop(t.audioBase, vol)
              .then(() => {
                AudioMgr.masterCrossfadeTo(t.audioBase);
              })
              .catch(() => {});
          }
        };

        anchor.onTargetLost = () => {
          activeTargets.delete(t.index);

          t.layerObjs.forEach(({ video, mesh }) => {
            try {
              video.pause();
            } catch {}
            if (mesh) mesh.visible = false;
          });
          if (t.particles) t.particles.visible = false;

          AudioMgr.stopWithFade(t.audioBase, 600);
          hideSpinner();

          if (calidad !== "hd") {
            t.cleanupTimeout = setTimeout(() => {
              t.layerObjs.forEach((obj) => {
                anchor.group.remove(obj.mesh);
                disposeLayer(obj);
              });
              t.layerObjs.length = 0;
              t.layersCreated = false;
              if (t.particles) {
                anchor.group.remove(t.particles);
                t.particles.geometry?.dispose?.();
                t.particles.material?.dispose?.();
                t.particles = null;
              }
            }, 5000);
          }

          setTimeout(() => {
            if (!activeTargets.size) return;
            let lastActiveIndex = null;
            activeTargets.forEach((i) => {
              lastActiveIndex = i;
            });
            const next = targets.find((tt) => tt.index === lastActiveIndex);
            if (next) AudioMgr.masterCrossfadeTo(next.audioBase);
          }, 50);
        };
      });

      // ====== Animación de partículas (solo activos) ======
      const animateParticles = () => {
        if (!particlesEnabled()) return;
        targets.forEach((t) => {
          const p = t.particles;
          if (!p || !p.visible || !activeTargets.has(t.index)) return;
          const positions = p.geometry.attributes.position.array;
          const type = p.userData.type;
          const count = positions.length / 3;
          switch (type) {
            case "rain": {
              const speed = p.userData.speed || 0.005;
              const areaY = p.userData.areaY || 0.5;
              for (let i = 0; i < count; i++) {
                const idx = i * 3;
                positions[idx + 1] -= speed;
                if (positions[idx + 1] < -areaY / 2)
                  positions[idx + 1] = areaY / 2;
              }
              break;
            }
            case "foam": {
              const speed = p.userData.speed || 0.002;
              const areaY = p.userData.areaY || 0.3;
              for (let i = 0; i < count; i++) {
                const idx = i * 3;
                positions[idx + 1] += speed;
                if (positions[idx + 1] > areaY / 2)
                  positions[idx + 1] = -areaY / 2;
              }
              break;
            }
            case "dragonfly": {
              const areaX = p.userData.areaX || 1,
                areaY = p.userData.areaY || 0.3,
                speed = (p.userData.speed || 0.002) * 0.002;
              for (let i = 0; i < count; i++) {
                const idx = i * 3;
                positions[idx] += (Math.random() - 0.5) * speed;
                positions[idx + 1] += (Math.random() - 0.5) * speed;
                positions[idx + 2] += (Math.random() - 0.5) * (speed * 0.5);
                if (positions[idx] > areaX / 2) positions[idx] = areaX / 2;
                if (positions[idx] < -areaX / 2) positions[idx] = -areaX / 2;
                if (positions[idx + 1] > areaY / 2)
                  positions[idx + 1] = areaY / 2;
                if (positions[idx + 1] < -areaY / 2)
                  positions[idx + 1] = -areaY / 2;
              }
              break;
            }
            case "fire": {
              const speed = p.userData.speed || 0.003;
              const areaY = p.userData.areaY || 0.25;
              for (let i = 0; i < count; i++) {
                const idx = i * 3;
                positions[idx + 1] += speed;
                if (positions[idx + 1] > areaY) positions[idx + 1] = 0;
              }
              break;
            }
          }
          p.geometry.attributes.position.needsUpdate = true;
        });
      };

      /* ====== Desbloqueo de AUDIO (una sola vez) ====== */
      const splash = document.getElementById("splash");
      const btnAudio = document.getElementById("btn-audio");
      // Dispara un tono diminuto (inaudible ~-50 dB) durante ~40ms para “despertar” el audio en iOS/Android
      function pingAudioOnce() {
        try {
          const ctx = AudioMgr.ctx;
          const osc = ctx.createOscillator();
          const g = ctx.createGain();
          g.gain.setValueAtTime(0.003, ctx.currentTime);
          g.gain.linearRampToValueAtTime(0.0, ctx.currentTime + 0.04);
          osc.frequency.value = 440;
          osc.connect(g).connect(AudioMgr.master);
          osc.start();
          osc.stop(ctx.currentTime + 0.05);
        } catch {}
      }

      const unlockAudioOnce = () => {
        try {
          AudioMgr.resume();
        } catch {}
        // El “ping” debe ocurrir dentro del mismo callback del gesto
        pingAudioOnce();

        audioUnlocked = true;

        // Si ya hay targets activos, arranca sus loops y hace crossfade
        let lastActiveIndex = null;
        activeTargets.forEach((i) => {
          lastActiveIndex = i;
        });
        targets.forEach((t) => {
          if (activeTargets.has(t.index)) {
            const vol = VOLUMES_BY_AUDIOBASE[t.audioBase] ?? 1.0;
            // Importante: no “await” aquí para mantener el stack del gesto
            AudioMgr.playLoop(t.audioBase, vol).catch(() => {});
          }
        });
        if (lastActiveIndex !== null) {
          const next = targets.find((tt) => tt.index === lastActiveIndex);
          if (next) AudioMgr.masterCrossfadeTo(next.audioBase);
        }

        hideSplash();
      };

      // Enganche robusto del primer gesto para desbloquear audio (iOS/Android/Desktop)
      (() => {
        let armed = true;
        const handler = () => {
          if (!armed) return;
          armed = false;
          window.removeEventListener("pointerdown", handler, true);
          window.removeEventListener("touchstart", handler, true);
          window.removeEventListener("click", handler, true);
          document.removeEventListener("keydown", keyHandler, true);
          unlockAudioOnce();
        };
        const keyHandler = (e) => {
          if (e.code === "Space" || e.code === "Enter") handler();
        };
        // Capturamos en fase de captura para ganar a otros listeners
        window.addEventListener("pointerdown", handler, {
          capture: true,
          once: true,
          passive: true,
        });
        window.addEventListener("touchstart", handler, {
          capture: true,
          once: true,
          passive: true,
        });
        window.addEventListener("click", handler, {
          capture: true,
          once: true,
          passive: true,
        });
        document.addEventListener("keydown", keyHandler, {
          capture: true,
          once: true,
        });
      })();

      let splashHideTimer;
      const showSplash = () => {
        splash.classList.add("show");
        clearTimeout(splashHideTimer);
        splashHideTimer = setTimeout(() => hideSplash(), SPLASH_AUTOHIDE_MS);
      };
      const hideSplash = () => {
        splash.classList.remove("show");
        // Si ya fue removido, esto no rompe nada:
        setTimeout(() => splash.remove?.(), 250);
      };

      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          hideSpinner();
          AudioMgr.stopAll();
        } else {
          // Al volver al foreground, si ya está desbloqueado y hay targets activos, relanza los loops
          if (audioUnlocked && activeTargets.size) {
            let lastActiveIndex = null;
            activeTargets.forEach((i) => {
              lastActiveIndex = i;
            });
            targets.forEach((t) => {
              if (activeTargets.has(t.index)) {
                const vol = VOLUMES_BY_AUDIOBASE[t.audioBase] ?? 1.0;
                AudioMgr.playLoop(t.audioBase, vol).catch(() => {});
              }
            });
            if (lastActiveIndex !== null) {
              const next = targets.find((tt) => tt.index === lastActiveIndex);
              if (next) AudioMgr.masterCrossfadeTo(next.audioBase);
            }
          }
        }
      });

      // ====== Adaptive Scaler por FPS (ventanas de 1.5s con histéresis) ======
      function startAdaptiveScaler() {
        let windowMs = 1500;
        let frames = 0;
        let t0 = performance.now();
        let stableCount = 0;

        const evalAndMaybeScale = (fps) => {
          let target = calidad;
          if (fps > 28 && calidad !== "hd") target = "hd";
          else if (fps < 22 && calidad !== "low") target = "low";
          else if (fps >= 22 && fps <= 28 && calidad !== "mid") target = "mid";

          if (target !== calidad) {
            stableCount++;
            if (stableCount >= 2) {
              // exige 2 ventanas seguidas
              setQuality(target);
              stableCount = 0;
            }
          } else {
            stableCount = 0;
          }
        };

        const tick = () => {
          frames++;
          const now = performance.now();
          if (now - t0 >= windowMs) {
            const fps = (frames * 1000) / (now - t0);
            evalAndMaybeScale(fps);
            frames = 0;
            t0 = now;
          }
          requestAnimationFrame(tick);
        };
        requestAnimationFrame(tick);
      }

      // ====== Inicio de cámara/AR ======
      const fpsBox = document.getElementById("fps");
      const start = async () => {
        showSplash();
        await mindarThree.start();
        showSplash();
        startAdaptiveScaler(); // <--- activa el ajuste dinámico por FPS

        let last = performance.now();
        let frames = 0;
        renderer.setAnimationLoop(() => {
          animateParticles();
          renderer.render(scene, camera);
          frames++;
          const now = performance.now();
          if (now - last >= 1000) {
            fpsBox.textContent = `${frames} fps`;
            frames = 0;
            last = now;
          }
        });
      };
      start();

      /* ====== Precalentar audio buffers de los 3 primeros targets ====== */
      [0, 1, 2].forEach((i) => {
        const base = targets[i]?.audioBase;
        if (base) AudioMgr.load(base).catch(() => {});
      });
    </script>
  </body>
</html>
